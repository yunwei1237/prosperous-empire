# 快速整合功能的工具介绍

## 故事

大家好，我是云苇，我最近想做一款MOD，起了一个非常好听的名字，叫**繁荣帝国**，当然，我以前也想过做一个MOD**战国群雄**。这两个脚本都是我想做但还没有完成的，也做了很长时间，一直是由于工作和个人的原因。之前也还做过一个快速生成脚本的工具，但因为各种原因，一直没有更新，可能以后也不会更新了。

之所以剧本没有做除了个人原因以外，还有很多关于MOD制作的问题，比如，剧本本身的功能不熟悉（想把源码全部看一遍，最后发现那是一个非常轻率的想法）;剧本东西太多无处下手，整合别人的功能都需要对别人的功能比较熟悉，才知道添加到哪里，哪些地方需要注意;添加过程复杂，测试功能更加复杂，由于小小的失误可能导致运行不起来，要不然就是大片的红色错误信息;这里有太多的问题，导致做剧本一直做不起来，当然人少也是最主要的原因。我之前也尝试过写一些工具，用于快速生成剧本，花费了大量时间做出来，我以为可以大杀四方的时间，才发现工具里面也有很多新的问题产生。后来，我就想着放弃吧，做剧本可能是一个理想，做一个功能还可以，要想做整个剧本，那真的需要太多时间和精力。

由于现在是在新型冠状病毒疫情期间，闲着也没事，过年时间公司放假时间比较长（越过越长的假期），我又想着能不能做一个MOD。当时我的激情真的很高涨，恨不得马上就把MOD做出来，然后拼命写了三四天，又发现一个人做MOD真的好难啊。那种感觉又让我回到了之前做剧本时的无力感。

所以就想就着，能不能做一个系统，能够将不同的功能拆分开，每一个功能就是一个模块，模块和模块之间以最少的依赖存在。一个模块可以是一个巡逻队系统，可以是一个玩家队员管理系统（同伴自动购买食物，分队去卖物品），村庄的建设系统，养殖系统，种植系统，采矿系统等等。最后有一个文件，在文件中保存着所有功能列表，如果我想要功能只要添加到这个列表中就行了，系统会自动将这些功能整合到系统，编译后在游戏中就可以找到了。如果不需要某个功能，只需要从列表中去掉，而不是在剧本中找到每一个修改过的地方，然后注释。

经过一段时间的幻想，设计，和代码（python语言）编写，终于将这个想法做成了一个比较初级的版本，而它完全支持我的幻想（中间有一次非常大的功能变更），我就给它起一个比较适合它的名字：**smart module**，也就是灵活的模块。这个工具基于**Module_system 1.153**，我直接使用了[骑马与砍杀Module System资源整合包](http://bbs.mountblade.com.cn/thread-330994-1-1.html)。现在虽然失效了，但是我在以前下载过，所以就一直保留着（感谢这位大大）。

工具地址：[地址](https://github.com/yunwei1237/prosperous-empire)

我害怕这个工具会像之前的工具一样出现问题，所以我就打算将**繁荣帝国**中所有的功能都实现一遍（有时间将繁荣帝国的功能列表上传），每次只需要一个模块一个模块地编写就好了。然后，我就开始了我的第一个模块，巡逻队。经过一段时间，我终于将巡逻队做完，并且，使用这个模块的人员可以根据自己的需求修改一些参数，这些参数对巡逻队模块产生比较大影响（如：城堡城镇村庄的巡逻队数量和军事强度，每一队人数上限，多久补充兵种和经验等等）。巡逻队的功能已经完全实现，可以参考模块：[巡逻队](https://github.com/yunwei1237/prosperous-empire/blob/master/src/modules/PatrolParty.py)

我写了几个模块，只有巡逻队完全写完（我想到功能 都完成 啦^_^），所以如想使用尽量参数巡逻队。

我这几天一起想着要不要把工具放出来，一方面担心工具会有一些比较大的问题，另一方面又担心一个人能够发现问题有限，希望大家多多测试工具，一起完善这个工具。

## 工具使用

我这里简单介绍下这个工具的使用。如果大家有很好的建议和使用方式，欢迎和我交流。

### 特性

这个工具本身有一些比较好的特性，我这里列下，以便大家能够更好理解这个工具

- 几乎零耦合
- 一键启用和禁用
- 模块功能
- 功能整合简单
- 测试简单
- 代码统一规范

### 模块

在这个工具中，每一个功能就是一个模块，每一个模块都是单独独立的文件。

#### 模块编写步骤

- 在**modules**（任何文件夹都可以）文件夹中创建一个py文件
- 在py文件中定义一个**dict(字典)变量**，编写功能时请参看**模块语法**。
- 功能写完后，将**dict(字典)变量**添加到**config_modules.py**文件中的**modules**集合中
- 修改**module_info.py**文件中的**export_dir**为你的游戏目录
- 执行**build_module.bat**(windos)或**build_module.sh**(linux或mac)脚本
- 运行游戏进行测试（只能在windos中运行游戏）

#### 模块语法

说白了一个模块其实就是一个字典（哈希表）类型的变量，里面包含了我们写的所有功能项。每一个项代表一个具体的信息或操作。

##### name

这个含义非常简单，就是一个模块的名字，要保证全局唯一。

##### enable

模块是否启用，也就是剧本编译时是否加入到游戏中，如果不指定这个值，默认会加入到游戏，所以禁用一个功能，只需要将这个值由True，更改成False就可了。编译游戏后，该模块的功能不会出现在游戏中。

##### dependentOn

如果在编写游戏过程中，发现有一些script已经有人写过了，可以在脚本中直接使用，但是需要将script所在的模块名称，加入到这个列表中。不加入也不会报错，但加入后工具会帮你检测依赖的模块是否参与游戏的编译，给你及时提醒。

##### 各个游戏项内容

剧本说得直白些，就是在module_system系统中加入我们自定义的代码，包含，troops,items,dialogs,strings,scripts等等。它们在本工具中也是一个项级别和name和enable是同一个级别，由于每一个操作都相同，所以我只介绍其中一个，其它的参考功能模块。

对于本系统来说，每一个模块项都面临者增加（append），删除（delete），插入(insert)，替换(replace)功能。

例如：在module_strings.py中添加一个字符串项;重写module_scripts.py中的game_get_troop_wage功能;为module_mission_templates.py文件的visit_town_castle战场控制器添加一个触发器;为了测试脚本在module_game_menus.py中的start_game_0菜单的continue选项后添加一个新的选项等等。

我把这些功能全部都归结为：**增加**，**删除**，**插入**，**替换**，**子操作**(children)五个操作。

在简介这些功能之前，我们得先介绍一个新的概念，**sign**(信号，其实可以翻译成选择器)。

##### sign

信号（选择器）：适合于删除，插入，替换功能（增加不需要，直接添加到数据末尾就行了，不需要选择器）

信号有四种形式：

1.id形式

也叫简单选择器，使用数据的id作为选择器，如，（玩家的id：player，斯瓦迪亚阵营的id：kingdom_1），适用于有id的数据选择。

2.下标形式

注：下标从0开始！！！

也叫下标选择器，使用【#数字】的方式作为选择器，如，（troops兵种集合的第一个数据：#0，factions阵营集合的第10个数据#11），适用于数据中的某一列。

3.复杂形式

复杂选择器主要分成两部分，

例如（对话）：

```
[anyone,"member_castellan_pretalk", [], "Anything else?", "member_castellan_talk",[]],
```

第一部分：是选择器，如：**member_castellan_pretalk:member_castellan_talk**，注：符号之间以冒号隔开（英文符号）

第二部分：是下标选择器，如：**[1,4]**，注：符号外使用方括号，符号之间使用逗号隔开（英文符号）

完整格式：member_castellan_pretalk:member_castellan_talk:[1,4]

选择器的格式的含义是，从数据中的1下标和4下标中选择数据，拼成一个新的字符串，与member_castellan_pretalk:member_castellan_talk作对比，如果相同就代表选择到，如果不相等，代表没有选择任何数据。

复杂选择器适用于没有id的数据行，从数据行中选择n（逻辑上无限）个数据，组成类似id的符号。以便能够在数据集合中准确定位。

4.复杂形式-限定

此模式和复杂形式相同，只有一个不同就是每一个选择器（第一个部分）的结尾是可以添加一个@符号，这个符号的含义是：请该选择器的所对就下标的数据作一些特殊处理，第一，把特殊符号（如果不是字母，数字，下划线，这三种符号，其它所有符号都是特殊符号）转换成下划线，第二，使用开头匹配方式，也就是说，我们不必把这个值全部列出，只要列出开始一部分就行了。

如：member_castellan_pretalk:Anything_else_@:member_castellan_talk[1,3,4]，我在**Anything_else_**后边加上了@符号，就是告诉系统，请把与我作对比的数据先做特殊处理，然后再与我进行对比。此形式适用于非常复杂的情况。

了解了sign选择器以后，我们就可以学习操作命令了

##### append

append命令对应的数据类型是List，list中保存的数据会追加的数据集合的末尾。

##### delete

delete命令对应的数据类型是List,list中保存的是sign集合，也就是选择器集合，只要选择到，就会从数据集合中删除。

##### insert

insert命令其实是两个命令：insertAfter和insertBefore。

insert集合对应的数据类型是list,list中的保存的数据是dict。

**insertAfter**中包含两个参数：

sing:指定一个选择器

data:指定要插入的数据集合

**insertBefore**的参数与insertAfter命令相同，唯一不同的是，insertBefore会将数据添加到选择器所对应数据行的前边，insertAfter会将数据添加到选择器所对应数据行的后边。

##### replace

replace参数与insertBefore命令相同。行为不同的是，将选中的数据删除后，进行添加到选择器所对应数据的前边。

为了更加深入理解命令，以strings添加数据为例（为了简单省略了name,enable等等属性的编写）：

```
"strings":{
    "append":[
        ("s5_s_patrol_party","数据会被添加到strings集合的末尾"),
    ],
    "insertBefore":[
        {
            "sign":"empty_string",
            "data":[
                ("test_string_insertBefore","在empty_string后方插入数据"),
                ("test_string_insertBefore2","在empty_string后方插入数据"),
            ]
        }
    ],
    "insertAfter":[
        {
            "sign":"yes",
            "data":[
                ("test_string_insertAfter","在yes前方插入数据"),
            ],
        }
    ],
    "replace": [
        {
            "sign": "empty_string",
            "data": [
                ("empty_string", "替换id为empty_string的数据"),
                ("empty_string2", "会被插入在id为empty_string的后边"),
            ],
        }
    ],
    ## 删除id为color_no_1的字符串，删除strings集合中第109个的字符串
    ## 删除复合选择器（从下标为0和1取值拼成字符串与【no_string:NO_STRING_@[0,1]】作对比，如果符合就删除）
    "delete":["color_no_1","#108","no_string:NO_STRING_@[0,1]"],
},
```

如果想看更多使用方法，请参考：[功能文件夹](https://github.com/yunwei1237/prosperous-empire/blob/master/src/modules)



## 剧本制作

### 策划

对于策划人员，每一个模块的开头就是该模块的一些参数信息，用于影响整个模块的功能和行为。如果再有人想制作一个MOD只需以下步骤：

- 要将喜欢的模块，加入到**config_modules.py**文件中的列表中（确保eanble属性值为True或没有这个属性）,并添加引用，
- 修改游戏的输出目录（**module_info.py**）。
- 执行**build_module.bat**(windos)或**build_module.sh**(linux或mac)脚本

一个剧本制作完成了。

注：我在写功能时会特别注意，将所有模块参数放到文件开头和做非常完整的注释说明，以便策划人员根据剧本需要修改数值。

### 程序员

对于游戏程序员来说，可能会比较痛苦，因为要编写功能的代码一行都不会减少， 而且相反，代码量比之前还要多，并且还要学习模块的语法，以便能够让代码顺序运行。不过测试起来可能会比较方便，我们可以单独测试我们自己的功能，不和别的模块同时测试，减少错误的机率，所有的代码都放到一个文件中，也比较方便阅读，因为所有你写的代码都在同一个文件中，你不会修改Module_system系统中的任何一行代码。

- 代码量增加
- 测试方便
- 代码独立 
- 详细的编译日志
- 出错率减少
- 功能几乎秒移植

注：我感觉我有点对不起程序，因为有时间，我自己设计的语法我都会写错误，然后仔细检查后，才发现忘记格式写错了。



## 最后

我说下我使用的工具吧

- pycharm 2018.2（pythond的ide工具）（[下载地址](https://download.jetbrains.com/python/pycharm-professional-2018.2.8.exe?_ga=2.207248979.1797983248.1584591531-1051353525.1510193100)）
- python2.7（下载地址[下载地址](https://www.python.org/ftp/python/2.7.17/python-2.7.17.amd64.msi)）
- Batch Scripts support(用于执行bat文件，在pycharm中的插件库中下载)
- github（用于保存代码永久不丢失:[地址](https://github.com)）
- git(工具[下载地址](https://git-scm.com/download/win))

最后，欢迎大家提供宝贵建议，也希望给喜欢做剧本的人带来便利。